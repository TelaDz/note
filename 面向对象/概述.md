# 对象

## 对象是一种以 键值对 描述的数据格式 key:vaule

### **proto** 基因链

#### 使用 new 创造对象

如果使用构造函数创建的字符和字符 布尔值 都会被放在堆中

如果不使用构造函数创建 都被放在栈中，但是归根结底他们的根本部分都是 Object

类 父类 子类 超类 对象

类 类别 是对一些具有相同属性和方法的集合做出的抽象概念类自身也可以是一个对象(类本身可以是虚拟的抽象概念)

抽象类别 描述了一个群体，这个群体中每个对象都有 1 个 a 的属性，默认值为 1，有一个 play 方法 只需要通过 new 这个类就可以创造出该类对象

```js
class Box extends Array {
  //Box的子类
  // class Box{
  a = 1;
  static b = 2;
  constructor() {
    super(); //执行超类的构造函数
  }
  play() {}
  static plays() {}
  join() {
    //如果该方法是超类的一个方法时
    super.join();
    //当需要执行超类的该方法内容时
  }
}

let b = new Box();
let b1 = new Box();

//Box相对b,b1这样的对象来说是一个抽象描述
```

class Box 是个生产线 Box() 是生产出来的车子

static 后//静态化

Box 变成了对象，这里的属性和方法就是对该种类的属性描述和方法内容，它不是针对实例化的对象产生 而是针对该类别统一描述

Box.b=10;

Box.play();

当需要完成一个新的类别时，这个类别是针对某个类别的拓展产生，这个新的类别就是基于原来类别的新类，也就是子类，而原来的类别相对于拓展新类别就是父类

这种不断拓展产生新的类别时，形成的关系链我们称为原型链(关系的不断延伸)

我们将最开的也就是最底层的父类称为基类，万物的基类就是 Object

子类的父类称为超类 super

对象就是通过实例化类别形成的内容

面向对象思路 告诉弟弟要干什么而不管弟弟怎么去做 只是提醒弟弟 具体怎么做是弟弟的事

**_只有对象才能调用方法_**

---

#### 自变量实例化

var obj={a:1;b=2};

console.log(obj);

obj.a=10;

打印出来的是 Objcet 虽然是按顺序执行 但是 Object 是从堆里取出的数据 点了三角 点的瞬间获取的值 显示的为 Objcet{a:10,b:2};

#### 构造函数实例化

var obj1=new Object({a:1,b:2}); //第一次不会显示 F5 刷新才变成{a:1,b:2} 从堆中拿出来 刷新后才变成字符串样式

第一次打开的时候看不到 是个 Objcet

- **以上两种 当 F5 刷新时 从缓冲中拿出对象**

堆中引用的方式

---

console.log(obj===obj1);//false

//引用地址完全不同

如果需要比对对象的属性和值是否完全相同 可以转换为字符串然后比对

console.log(JSON.stringify(obj)===JSON.stringify(obj1)); //true

---

[] 单独一个是引用地址

console.log([]===[]);//false

console.log([]===true);//false

console.log(![]===true);//true

![]隐式转换

---

var obj2=Object.create(obj);//以 obj 对象为原型创建出 obj2

脱离了类别直接以对象来继承的方式

console.log(obj2);//{} 但是在**proto** 继承了 obj 这里面是有 obj 的对象的

---

如果原型链对应的对象发生修改，该对象的原型链也会发生变化

获取对象属性时，如果没有该对象属性，则查找离其最近原型链上的该属性，如果有则返回该值

- **自己的属性叫对象属性 原型链下的属性叫原型链属性**

设置对象属性时，只能设置该对象的对象属性，不能修改对象的原型属性，设置一个对象属性时，先查看是否有该对象属性，如果没有，则创建一个属性，赋值，如果已经有了该对象属性，则修改该对象属性

ES5 允许直接操作原型的属性值，但是我们限制只能获取其值，不要修改值(容易出问题)

---

delete obj2.b;//删除对象的对象属性
delete obj2.**proto**.b;

obj=null;
console.log(obj2);//此时 obj2 中还是有 obj 的属性 因为 obj 的对象内容仍然被 obj2 引用

清除 obj 的话使用

obj2.**proto**=obj2.**proto**.**proto**;

---

#### Object.assign()

是浅复制 仅去除了对象的第一层属性的引用关系，而第二层或者更深的引用关系仍然存在

Object.assign(目标对象，源对象 1，源对象 2.。。)；//这个方法返回目标对象(引用对象相同)

可以复制多个对象 它只能复制对象的可以枚举属性

(枚举：不能用 forEach 遍历)

如果多个源对象复制，有多个相同的属性，后面的源对象属性值会覆盖前面源对象的属性值

对象属性的定义属性

---

#### Object.defineProperty()

ES5 ES6 都有的 原生 JS 有的 任何框架都可用

```js
var obj = {};
obj.a = 10;
obj["b"] = 20;

Object.defineProperty(obj, "a", {
  value: 10,
  //下面三个描述属性都是默认值是false
  configurable: true, //不可删除 不可修改描述对象 4条属性
  enumerable: true, //true 是否可枚举 反之
  writable: true //不可修改属性(只读属性)
});

//当使用set和get的时候 上面4种中 value:10,writable:true, 不能写 一般使用两种写法
Object.defineProperty(obj, "a", {
  configurable: true,
  enumerable: true,
  set: function(value) {
    this._a = value;
  },
  get: function() {
    return this._a;
  }
});
```

事件驱动 数据注入 两种模式

数据注入改变事件驱动 变成注入驱动模式

定义多个属性

```js
Object.defineProperty(obj, {
  a: {
    value: 1
  },
  b: {
    enumerable: true,
    writable: true,
    value: 2
  },
  c: {
    configurable: true,
    writable: true,
    value: 3
  },
  d: {
    enumerable: true,
    set: function(value) {
      this._d = value;
    },
    get: function() {
      if (this._d) this._d = 0; //点击时获取这个属性0
      return this._d;
    }
  }
});
```

- **(...) 都是 set get 定义的属性**

---

#### Object.getOwnPropertyNames(对象)

获取对象属性名的数组

var arr=Object.getOwnPropertyNames(obj)//获取的是对象的属性名字并没有值(描述对象)

#### Object.getOwnPropertyDescriptor(obj,"a")

var desc=Object.getOwnPropertyDescriptor(obj,"a")//获取对象属性的描述对象

### 对象深复制

```js
```

---

日期也是对象

正则表达式也是对象

数组也是对象

判断基类是不是对象 typeof ?

null 也是对象

任何一个对象都有它的 constructor

new RegExp(前面正则，后面 i/g) 对象类型

HTML 属于接口方式 不能 new

原型下不能深复制(HTML)
