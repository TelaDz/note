# 函数

函数也是对象，存在堆中

## 1、函数的声明

- 创建函数以命名格式创建时将会在 script 标签添加时优先存储在堆中，并且在栈中以该函数名命名的变量
- var fn2=function(){}匿名函数 当赋值给一个变量时，该函数才创建成功
- 如果该匿名函数没有赋值给变量
- (function(){

  })();//自执行匿名函数一次运行完成就流浪了(没有销毁 除非浏览器进行了运算处理)

### 为什么使用函数

- 函数对任何一门语言来说都是核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。在javascript里，函数即对象，程序可以随意操控它们。函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，它给javascript带来了非常强劲的编程能力。
- 相对于变量，函数会优先加载。所以不用担心函数声明在调用前还是调用后。
- 调用函数时会先在本机活动对象中查询，即当前js文件中查询，如果没有才会向上查询，所以若在两个js文件中定义相同函数名，这两个js文件内部调用各自的函数，其他js文件中调用最后声明的函数。

---

### 函数的声明---普通函数声明

- ```js
  function funcname([arg1 [,arg2 [...,argn]]]){
    statement;
  }
  ```

- 通常来说函数的声明会有一个返回值，如果没有设置return，该函数默认返回未undefined，如果设置，将返回该值。执行函数后会返回该值。

- ```js
  function  abc（）{
    var s=3+4；
    return s;
  }
  var s1=abc();
  s1===7;
  ```

---

### 函数的声明---匿名函数声明1

- ```js
  var box=function(num1,num2){
       retrun num1+num2;
  }
  ```

- 这是匿名函数声明，声明函数的时候没有赋予名称，但是函数声明好以后却赋值给了box，这里注意box并不是num1+num2的值，而是function定义的这个匿名函数。

---

### 函数的声明---匿名函数声明2

- 在对象中，可以设置一个属性是一个函数，这样就给了对象定义了一个方法。

- ```js
  var obj={
    name:”zhangsan”,
    fire:function(num1,num2){
            var s=num1+num2;
        return s;
    }
  }
  ```

---

### 函数的声明---Function构造函数

- 使用Function构造函数
- var box=new Function('num1','num2','retun num1+num2');//num1,num2参数，最后的字符串是函数体
- PS:第三种方式我们不推荐，因为这种语法会导致解析两次代码（第一次解析常规JS代码，第二次是解析传入构造函数中的字符串），从而影响性能，但我们可以通过这种语法来理解函数是对象，函数名是指针的概念。

### 重复

- 变量的重复声明是无用的，不会覆盖之前同一作用域声明的变量，但函数的重复声明会覆盖前面的声明的同名函数或同名变量。
- 变量的重复声明无用

```js
var a = 1;
var a;
console.log(a);//1
```

- 覆盖同名变量

```js
var a;
function a(){
    console.log(1);
}
a();//1
```

- 覆盖同名函数

```js
a();//2
function a(){
    console.log(1);
}
function a(){
    console.log(2);
}
```

---

## 2、函数的执行

### 函数的执行

- 函数执行 ：函数名()
- 执行后，可以完成函数的代码内容，如果函数内有return 值，这时候执行后会返回该值。

- ```js
  function abc() {
          return 3+4;
      }
  var s=abc();
  ```

- 如果没有return，则执行完所有代码

---

### 函数的独立执行

- 函数自身是可以独立执行的，并且也可以把独立执行的结果赋值给一个变量。

- ```js
    var  s=0
  (function(){
    s=4+5;
  })()//匿名函数自己执行
  ```

- 注意匿名函数用小括号括住，最后再执行小括号。
- 注意，除了匿名函数可以独立执行，实名函数也是可以独立执行的，不过这种独立执行就不能在该函数中添加参数了，并且匿名函数，也只能在此执行一次，不能多次调用，显而易见的好处是，该函数内的变量统统是私有变量，有关该部分内容我们在后面详细说明

---

### 函数的call

- 函数名.call([thisObj[,arg1[, arg2[, [,.argN]]]]])//thisObj 可选项。将被用作当前对象的对象。 arg1, arg2, , argN 可选项。将被传递方法参数序列。
- call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。
- 如果没有提供 thisObj 参数，那么 Global 对象被用作thisObj。说明白一点其实就是更改对象的内部指针，即改变对象的this指向的内容。这在面向对象的js编程过程中有时是很有用的。

---

### 函数中apply

- 语法：apply([thisObj[,argArray]])
- 定义：应用某一对象的一个方法，用另一个对象替换当前对象。
- 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。
- 如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。
- 其实apply和call基本相似，这里传参的模式产生变化而已，在call中传参使用了逐个传入，apply中是以数组传参带入。

---

### 例

```js
function fn() {
    console.log("aaa");
}
fn.call();
fn.apply();

function fn(){
        //在非ES6严格模式，this是window
    this.a=a;
    this.b=b;
}

// fn(3,5)
// console.log(a,b);

var obj={};
fn.call(obj,3,5)
console.log(obj); {a:3,b:5}//使用call和apply，将一个对象混入到函数中，代替函数中this
//不能代替别的
fn.apply(obj,[3,5])
console.log(obj);//执行函数并且混入对象替代函数中的this，但是再给函数传参时不是一个个传入，而是数组方式传入
```

如果函数中没有 this，使用 call 没有意义

执行函数，并且将函数中要替代的对象写在第一个参数中

```js
var obj = {
    a: 1,
    b: 2,
    c: function() {
    //如果替代this的对象是null或者undfined时，会将this重新指向window
        console.log(this.a + this.b);
        }
    };
var obj1 = { a: 3, b: 5 };
obj.c.call(obj1); //输出8
obj.c.call();//第一个参数是必填的//不填或者null或者undefind

```

---

## 3、函数的删除

- 当函数不在使用时，就需要删除，函数也是对象，如果不删除，它将常驻内存中，如果该函数不再使用就可以使用删除彻底清除掉该函数。但是只有函数是匿名定义的或者通过构造函数创建的才可以被删除。
- 1、匿名函数删除(通常指事件或者使用arguments.callee 可访问的变量指向该函数，唯一能引用它的方式就是通过 arguments.callee)
- 2、对象下的方法删除
- 函数声明语句创建的变量无法删除，这一点和变量声明一样。

```js
function foo(){
  console.log(1);
}
delete foo; //false
console.log(foo());//1
```

---

## 4、参数和return

### 函数参数

- 参数是指由外部传入到函数中的变量，仅作为变量使用，但是该变量可以是任何内容，包括函数。
- 被传入的参数作为私有变量使用，可以被覆盖掉。
- 为什么要从外部带入参数。一般来说函数是独立处理某段代码的集合，如果，这段代码需要重复执行，就会设计出函数，在不同的地方调用，达到代码共用的目的，减少代码量。但是在某些时候，虽然是同样的代码，但是我们需要它发挥出的作用更大，可以解决不同的问题，这时候，传入的参数就可以起到代码干预作用，在同一个函数中解决了很多不同的问题。这时候设计函数的独立性就显得非常重要了。当然，任何事情解决都不是绝对的，过度设计复杂的函数有时候反到会让代码效率降低。
- 同时，外部传入的参数可以节省全局变量的定义，甚至保证函数中的部分变量的独立性。

- **ES5仅支持写入参数**，参数过多就不填参或者以数组的方式填参

```js
// ES5
function fn(a, b) {
    console.log(a, b);
}
fn(3, 5);
function fn1() {
    console.log(arguments);
    // arguments.callee --->指当前函数自身
    //抽象化函数要使用arguments.calle来执行当前函数
    // arguments.callee.caller-->回调当前函数的函数
    // 只能使用ES5中,ES6的严格模式中不能使用
}
fn1(2, 3, 4, 5, 6);
var arr = [1, 2, 3, 4, 5];
fn1.apply(null, arr);

```

- ES6中，必填参数写在最前面(**没有设置默认值的都为必填参数**)，设置默认值的参数为选填参数，放在后面

```js
// ES6
// 设置参数时, 必填参数写在最前面, 设置默认值的参数是选填参数, 放在后面
function fn2(a, b = 0) {
}
// 解构赋值填参
function fn3([a, b = 0]) {
}
// 对象解构赋值填参, 选填和必填随意放入, 只需要属性名相同
function fn4({ b = 2, a }) {
    console.log(a, b);
}
fn4({ a: 10 });//10 2
function fn5(...arg) {
    console.log(arg);
}
fn5(1, 2, 3, 4, 5);//(5) [1, 2, 3, 4, 5]
var arr = [1, 2, 3];
fn5(...arr);//(3) [1, 2, 3]
fn5.apply(null, arr);//(3) [1, 2, 3]
```

...扩展运算符不计入length

---

### arguments对象

- ECMAScript函数不介意传递进来多少参数，也不会因为参数不统一而错误，实际上，函数体内可以通过arguments对象来接收传递进来的参数。
- arguments对象的length属性可以得到参数的数量
- 我们可以利用length这个属性，来智能的判断有多少参数，然后把参数进行合理的应用，比如，要实现一个加法运算，将所有传递来的数字累加，而数字的个数又不确定。

---

### return

- return 语句会终止函数的执行并返回函数的值。return 是javascript里函数返回值的关键字，一个函数内处理的结果可以使用return 返回，这样在调用函数的地方就可以用变量接收返回结果。return 关键字内任何类型的变量数据或表达式都可以进行返回，甚至什么都不返回也可以
- return 也可以作为阻止后续代码执行的语句被使用

- ```js
    function abc(){
    if(bool) return;
  }
  ```

- 这样可以有效的控制语句在一定的条件下执行，不过一定要与break区分，break是用在条件当中，跳出的也仅仅是条件和循环，但是return 却可以跳出函数，仅仅是针对函数使用，如果没有函数是不能使用return的。
- 返回一个数据
- **工厂模式**
  - createDIV
- **单例模式**(唯一的实例)在任何地方或者调用时都是唯一的实例化对象(数据池，中介者)
  - if()return elem;
- 通过参数传入的对象
- 如果参数是一个函数，返回的是回调函数的结果(**适配器模式**)
- 返回的是一个私密的对象

  - ```js
      function fn11(){
      var obj={a:1};
      return function(){
          obj.a++;
          return obj;
      }
        }
      var fn=fn11();
      var o=fn();
      var o1=fn();
      console.log(o===o1);//true
    ```

- 返回一个数组,返回多个元素
- 返回对象，返回多个元素
- 返回一个函数体
- 跳出

---

### return返回对象

- 在函数中，return是可以返回任何值得，包括对象和函数，为了能够返回一个私有的对象，通常可以使用return

- ```js
    function fun1(){
    return {
          a:1,
          b:2,
          fun2:function(){
                 console.log(this.a+this.b);
            }
        }
    }
    var obj=fun1();
    obj.fun2();
  ```

- 这是自定义函数，然后执行以后赋值给obj，然后才去执行fun2

- ```js
    var obj1=(function(){
    return {
          a:1,
          b:2,
          fun2:function(){
                 console.log(this.a+this.b);
            }
    }
  })();
  obj1.fun2();
  ```

- 这个直接定义一个匿名函数，并且自动执行赋值obj，这里obj就是返回的值并不是匿名函数。那么我们为什么要用如此复杂的方式来定义对象呢，原因是，我们可以在这个对象中定义一系列的私有变量，减少外部变量和对象属性的使用。

---

## 5、函数也是对象

### 函数也是对象

- 函数有自身的属性，也可以自身的方法,fun1是一个函数，同时他也时一个对象，因此你可以为他定义属性和方法。注意，如果要执行函数，用fun1();但是要调用函数的方法或者属性时，就不能加小括号了，因为fun1才是对象，fun1()是获得了执行的结果。而结果中并没有fun2的方法。因为fun1是对象，因此，在执行fun2后，打印的this就是fun1这个对象了而不是window

- ```js
    function fun1(){
        console.log(this);
    }
    fun1.a=3;
    fun1.fun2=function(){
    console.log(this.a);
    }
    fun1();
    fun1.fun2();
  ```

---

### 函数的属性定义

- 当函数还没有被实例化的时候，其实他的属性并不能被写在函数内部，a:3这种写法是有误的，因为函数虽然和对象一样都是{}，但是a:3并不适宜写在函数中，但是程序也不会报错，第二个是定义了一个函数内部的私有变量，第三个是定义了一个window的共有变量，最下面的fun1.a=6才是真正的属性

- ```js
    function fun1(){
    a:3;
    var a=4;
    this.a=5;
    }
    fun1.a=6;
    console.log(fun1.a);
  ```

---

### length

- JS中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接收的命名参数的个数。

- ```js
    function box(name,age){
        alert(name+age);
    }
    alert(box.length);
  ```

console.log(函数名.length);显示的是参数的个数

arguments.length是实际带入参数的个数，如果函数没有参数但是执行函数时内写了值或其他的什么这时函数名.length还是0

...扩展运算符不计入参数个数

---

如果函数是构造函数时，该函数的属性和方法就是当前构造函数对应类的静态属性和方法

当使用new实例化函数执行时，这个函数就叫做构造函数
